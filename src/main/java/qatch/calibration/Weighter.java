package qatch.calibration;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.opencsv.CSVReader;
import org.apache.commons.io.FileUtils;
import qatch.utility.FileUtility;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.util.*;

/**
 * Utility class responsible for deriving the weights (TQI-Characteristics layer and Characteristics-Properties layer)
 * described by hand-entered comparison matrices as part of the analytical hierarchy process.
 *
 * It should ensure the hand-entered matrices match TQI, characteristic, and properties nodes
 * described in the quality model and the data format in the matrices is valid.
 *
 * The class should provide functionality to return a mapping of weights over the two layers given
 * a quality model description and comparison matrices as input by running R scripts.
 */
public class Weighter {

    // Methods

    /**
     * Run weight elicitation process
     *
     * @param comparisonMatricesDirectory
     *      Path to directory containing hand-entered comparison matrices for TQI and characteristic nodes
     *      for the intended quality model.  The files in this directory are likely .csv files.
     * @param tempWeightsDirectory
     *      Location to directory to temporarily store the weights.json file generated by R analysis.
     * @return
     *      Collection of WeightResult objects.  These are the object representations of each entry in
     *      weights.json generated by the R weight elictation script.
     */
    public static Set<WeightResult> elicitateWeights(Path comparisonMatricesDirectory, Path tempWeightsDirectory) {

        // Precondition checks
        if (!comparisonMatricesDirectory.toFile().isDirectory()) {
            throw new RuntimeException("Parameter comparisonMatricesDirectory must be a directory");
        }
        if (Objects.requireNonNull(comparisonMatricesDirectory.toFile().listFiles()).length < 1) {
            throw new RuntimeException("At least one file must exist in comparisonMatricesDirectory");
        }


        // Create directory for temporary generated file results if not yet exists
        tempWeightsDirectory.toFile().mkdirs();

        // Run R script
        RInvoker.executeRScript(RInvoker.Script.AHP, comparisonMatricesDirectory, tempWeightsDirectory, FileUtility.getRoot());

        // Parse node name ordering for each matrix
        // TODO: eventually easiest to just have R map the names to the weights instead of parsing the files again
        Map<String, ArrayList<String>> weightNameOrders = parseNameOrder(comparisonMatricesDirectory);

        // Transform into WeightResults objects
        Set<WeightResult> weightResults = new HashSet<>();
        File weightsJson = new File(tempWeightsDirectory.toFile(), "weights.json");

        try {
            FileReader fr = new FileReader(weightsJson);
            JsonObject jsonObject = new JsonParser().parse(fr).getAsJsonObject();
            jsonObject.keySet().forEach(nodeName -> {

                /*
                 * TODO: the below regex 'replaceAll("\\.")' commands are due to the R script transforming spaces in
                 *  column names with dots.  This regex will be an issue if the input quality model has a node name
                 *  with an intentional dot. Change the r-script to reproduce names with spaces and then remove the regex calls.
                 */
                if (!weightNameOrders.containsKey(nodeName.replaceAll("\\.", " "))) {
                    throw new RuntimeException("parseNameOrder failed to create ordering for node name " + nodeName +
                        ". Check the quality model description and comparison matrices for naming inconsistencies.");
                }

                JsonArray nodeWeights = jsonObject.getAsJsonArray(nodeName);
                ArrayList<String> nameList = weightNameOrders.get(nodeName.replaceAll("\\.", " "));

                if (nodeWeights.size() != nameList.size()) {
                    throw new RuntimeException("nodeWeights and nameList arrays do not match lenghts");
                }

                WeightResult weightResult = new WeightResult(nodeName.replaceAll("\\.", " "));
                // zip-like function would be great here if Java eventually supports a one-line version of it
                for (int i = 0; i < nodeWeights.size(); i++) {
                    weightResult.weights.put(nameList.get(i), nodeWeights.get(i).getAsDouble());
                }

                weightResults.add(weightResult);
            });

            fr.close();

        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            FileUtils.deleteDirectory(tempWeightsDirectory.toFile());
        } catch (IOException e) {
            e.printStackTrace();
        }

        return weightResults;
    }


    /**
     * Extract the left-to-right order of the comparison matrix characteristic or property names.
     * Ordering is necessary because the weights.json output from the R script generates weights in order according
     * to the left-to-right comparison matrix it receives as input.
     * Eventually this method should be depreicated by modifying the R-script to automatically attach the names
     * to its output.
     *
     * @param comparisonMatricesDirectory
     *      Path to the directory holding the comparison matrix files to extract name order from.
     *      E.g. "src/comparison_matrices/"
     * @return
     *      Mapping of {
     *          Key: node name of weights receiver,
     *          Value: left-to-right ordered list of characteristic or property names under comparison
     *      }
     */
    static Map<String, ArrayList<String>> parseNameOrder(Path comparisonMatricesDirectory) {

        Map<String, ArrayList<String>> orderedWeightNames = new HashMap<>();
        for (final File matrixFile : Objects.requireNonNull(comparisonMatricesDirectory.toFile().listFiles())) {

            try {
                FileReader fr = new FileReader(matrixFile);
                CSVReader reader = new CSVReader(fr);
                String[] header = reader.readNext();

                String nodeName = header[0];
                ArrayList<String> weightNameOrder = new ArrayList<>(Arrays.asList(header).subList(1, header.length));

                orderedWeightNames.put(nodeName, weightNameOrder);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return orderedWeightNames;
    }
}
